function countingSortInsert(e,t,s,r){if(!(e instanceof Array))throw new TypeError('1st param "arr" must be an array');if(!(t instanceof Array))throw new TypeError('1st param "arrReduced" must be an array');for(let e=r+1;e<t.length;e++){const s=t[e];s&&(s[0]++,s[1]++)}const n=t[r];if(n)n[1]++;else{for(var i=r-1;i>=0;i--){const e=t[i];if(e){const s=e[1]+1;t[r]=[s,s];break}}i<0&&(t[r]=[0,0])}e.splice(t[r][1],0,s)}Vue.component("abbreviation-autocomplete",{data:()=>({focused:!1,listener:{searchTextEnabled:!1,selectEnabled:!1},recentlySelected:!1,selected:-1,unprintableKeys:["Alt","ArrowDown","ArrowLeft","ArrorRight","ArrowUp","CapsLock","ContextMenu","Control","Delete","End","Escape","F1","F2","F3","F4","F5","F6","F7","F8","F9","F10","F11","F12","Home","Insert","NumLock","PageUp","PageDown","Shift","Tab"]}),props:{data:{required:!0,type:Array},limit:{default:1/0,type:Number},minSearchTextLength:{default:1,type:Number},placeholder:String,searchText:{default:"",type:String}},computed:{dataSorted(){let e=this.data.slice();return e.forEach((t,s)=>{e[s]={option:t}}),this.sortData(e),e},searchList(){if(this.searchText.length>=this.minSearchTextLength){const e=[],t=[];return this.dataSorted.forEach(s=>{const r=s.option.toLowerCase().indexOf(this.searchText.toLowerCase());if(r>=0){let n=s.option,i=this.searchText.length,a=r,o={leftText:n.substr(0,a),highlight:n.substr(a,i),rightText:n.substr(a+i),option:n,substrIndex:a};countingSortInsert(t,e,o,r)}}),t.length<=this.limit?t:t.slice(0,this.limit)}return[]}},methods:{onSearchTextType(e){this.unprintableKeys.includes(e.key)||(this.recentlySelected?this.recentlySelected=!1:(this.focused=!0,this.selected=-1),this.listener.searchTextEnabled&&this.$emit("update:searchText",this.searchText))},onUnfocus(){this.focused=!1},select(){-1!==this.selected&&(this.focused=!1,this.listener.selectEnabled&&(delete this.searchList[this.selected].substrIndex,this.$emit("select",this.searchList[this.selected])),this.searchText=this.searchList[this.selected].option,this.recentlySelected=!0)},selectDown(){this.selected=(this.selected+1)%this.searchList.length},selectUp(){-1===this.selected&&(this.selected=0);const e=this.searchList.length;this.selected=(this.selected+e-1)%e},setSelected(e){this.selected=e},sortData(e){e.sort((e,t)=>e.option.localeCompare(t.option))}},template:'\n<div class="abbreviation-autocomplete">\n  <input type="text" :placeholder="placeholder" v-model="searchText" @focus="focused = true" @blur="onUnfocus" @keyup.enter="select" @keyup="onSearchTextType" @keydown.down="selectDown" @keydown.up="selectUp">\n  <ul v-show="focused" @mousedown="select">\n    <li v-for="(element, index) in searchList" :class="{ selected: index === selected }" @mouseover="setSelected(index)">\n      <span> {{ element.leftText }}</span><span class="highlight">{{ element.highlight }}</span><span>{{ element.rightText }}</span>\n    </li>\n  </ul>\n</div>\n',created(){if(!(this.data instanceof Array))throw new TypeError("ERROR: The autocomplete data must be an array");this.data.forEach(e=>{if("string"!=typeof e)throw new TypeError("ERROR: The autocomplete data array can only contain strings")});let e=this.$listeners;e&&(e["update:searchText"]&&(this.listener.searchTextEnabled=!0),e&&e.select&&(this.listener.selectEnabled=!0))}});
